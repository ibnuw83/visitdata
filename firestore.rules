/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a role-based access control model with user-owned profiles.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information; accessible only to the user and admins.
 * - /destinations/{destinationId}: Stores public destination data; publicly readable, but write access is restricted.
 * - /categories/{categoryId}: Stores public destination categories; publicly readable, but write access is restricted.
 * - /countries/{countryId}: Stores public country data; publicly readable, but write access is restricted.
 * - /destinations/{destinationId}/visits/{visitId}: Stores monthly visit data, with access controlled by destination managers and admins.
 * - /unlock-requests/{requestId}: Stores unlock requests, accessible to the requester and admins.
 * - /settings/app: Stores global app settings, accessible to admins only.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Destinations, categories, and countries are publicly readable but only writable by admins or "pengelola".
 * - Visit data access is restricted to managers ("pengelola") assigned to the destination and admins.
 * - Unlock requests can be created by any authenticated user, but only admins can process them.
 * - Global app settings are only accessible to admins.
 * - Listing of users is forbidden.
 *
 * Denormalization for Authorization:
 * - The `VisitData` entity does not include a denormalized manager ID. Instead, we rely on checking user roles and assigned destinations.
 * - The `UnlockRequest` entity includes both `requestedBy` and `requesterName` to display requester information even if the user profile is later deleted.
 *
 * Structural Segregation:
 * - No separation of public and private collections. All data is stored in a single set of collections with access control managed by rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data.
     * @path /users/{userId}
     * @allow (get) Authenticated user can read their own profile.
     * @allow (create) Authenticated user can create their profile if the userId matches their auth.uid.
     * @allow (update) Authenticated user can update their own profile.
     * @allow (delete) Authenticated user can delete their own profile.
     * @deny (get) Authenticated user cannot read another user's profile.
     * @deny (create) Unauthenticated user cannot create a profile.
     * @deny (update) Authenticated user cannot update another user's profile.
     * @deny (delete) Authenticated user cannot delete another user's profile.
     * @principle Enforces document ownership for writes and restricts read access to the owner.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && existsAfter(/databases/$(database)/documents/users/$(userId));
      }

      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.uid == request.auth.uid;
      allow update: if isExistingOwner(userId) && isOwner(userId) && request.resource.data.uid == request.auth.uid;
      allow delete: if isExistingOwner(userId) && isOwner(userId);
    }

    /**
     * @description Controls access to destination data.
     * @path /destinations/{destinationId}
     * @allow (get) Any user can read destination data.
     * @allow (list) Any user can list destinations.
     * @deny (create) Only 'pengelola' or 'admin' can create a destination.
     * @deny (update) Only 'pengelola' or 'admin' can update a destination.
     * @deny (delete) Only 'admin' can delete a destination.
     * @principle Public read access with restricted write access based on user role.
     */
    match /destinations/{destinationId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isAdmin() {
        return isSignedIn() && (getUserRole() == 'admin');
      }

      function isPengelola() {
        return isSignedIn() && (getUserRole() == 'pengelola');
      }

      function getUserRole() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
      }

      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn() && (isPengelola() || isAdmin());
      allow update: if isSignedIn() && (isPengelola() || isAdmin());
      allow delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Controls access to category data.
     * @path /categories/{categoryId}
     * @allow (get) Any user can read category data.
     * @allow (list) Any user can list categories.
     * @deny (create) Only 'pengelola' or 'admin' can create a category.
     * @deny (update) Only 'pengelola' or 'admin' can update a category.
     * @deny (delete) Only 'admin' can delete a category.
     * @principle Public read access with restricted write access based on user role.
     */
    match /categories/{categoryId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isAdmin() {
        return isSignedIn() && (getUserRole() == 'admin');
      }

      function isPengelola() {
        return isSignedIn() && (getUserRole() == 'pengelola');
      }

      function getUserRole() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
      }

      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn() && (isPengelola() || isAdmin());
      allow update: if isSignedIn() && (isPengelola() || isAdmin());
      allow delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Controls access to country data.
     * @path /countries/{countryId}
     * @allow (get) Any user can read country data.
     * @allow (list) Any user can list countries.
     * @deny (create) Only 'pengelola' or 'admin' can create a country.
     * @deny (update) Only 'pengelola' or 'admin' can update a country.
     * @deny (delete) Only 'admin' can delete a country.
     * @principle Public read access with restricted write access based on user role.
     */
    match /countries/{countryId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isAdmin() {
        return isSignedIn() && (getUserRole() == 'admin');
      }

      function isPengelola() {
        return isSignedIn() && (getUserRole() == 'pengelola');
      }

      function getUserRole() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
      }

      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn() && (isPengelola() || isAdmin());
      allow update: if isSignedIn() && (isPengelola() || isAdmin());
      allow delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Controls access to visit data for each destination.
     * @path /destinations/{destinationId}/visits/{visitId}
     * @allow (get) Any user can read visit data.
     * @allow (list) Any user can list visit data.
     * @deny (create) Only 'pengelola' assigned to destination or 'admin' can create visit data.
     * @deny (update) Only 'pengelola' assigned to destination or 'admin' can update visit data.
     * @deny (delete) Only 'admin' can delete visit data.
     * @principle Restricts write access to assigned managers and admins.
     */
    match /destinations/{destinationId}/visits/{visitId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isAdmin() {
        return isSignedIn() && (getUserRole() == 'admin');
      }

      function isPengelola() {
        return isSignedIn() && (getUserRole() == 'pengelola');
      }

      function getUserRole() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
      }

       function isAssignedDestinationManager(destinationId) {
            return isSignedIn()
                && (getUserRole() == 'pengelola')
                && (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.assignedLocations.hasAny([destinationId]));
        }

       function isExistingAssignedDestinationManager(destinationId, visitId) {
            return isAssignedDestinationManager(destinationId) && existsAfter(/databases/$(database)/documents/destinations/$(destinationId)/visits/$(visitId));
        }

      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn() && (isAssignedDestinationManager(destinationId) || isAdmin());
      allow update: if isSignedIn() && (isAssignedDestinationManager(destinationId) || isAdmin());
      allow delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Controls access to unlock requests.
     * @path /unlock-requests/{requestId}
     * @allow (create) Any authenticated user can create an unlock request.
     * @allow (get) Any authenticated user can read an unlock request if they are the requester.
     * @allow (list) Any authenticated user can list unlock requests if they are the requester.
     * @deny (update) Only 'admin' can update an unlock request.
     * @deny (delete) No one can delete an unlock request.
     * @principle Allows creation by any user, but restricts modification to admins.
     */
    match /unlock-requests/{requestId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isAdmin() {
        return isSignedIn() && (getUserRole() == 'admin');
      }

      function isOwner(requestedBy) {
        return request.auth.uid == requestedBy;
      }

      function getUserRole() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
      }

      allow get: if isSignedIn() && isOwner(resource.data.requestedBy);
      allow list: if isSignedIn() && isOwner(resource.data.requestedBy);

      allow create: if isSignedIn() && request.resource.data.requestedBy == request.auth.uid;
      allow update: if isSignedIn() && isAdmin();
      allow delete: if false;
    }

    /**
     * @description Controls access to global app settings.
     * @path /settings/app
     * @deny (get) Only admins can read app settings.
     * @deny (list) Listing is not applicable for a single document.
     * @deny (create) Only admins can create app settings.
     * @deny (update) Only admins can update app settings.
     * @deny (delete) Only admins can delete app settings.
     * @principle Restricts all access to admins only.
     */
    match /settings/app {
      function isSignedIn() {
        return request.auth != null;
      }

      function isAdmin() {
        return isSignedIn() && (getUserRole() == 'admin');
      }

      function getUserRole() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
      }

      allow get: if isSignedIn() && isAdmin();
      allow list: if false;

      allow create: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && isAdmin();
      allow delete: if isSignedIn() && isAdmin();
    }
  }
}