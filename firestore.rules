/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a role-based access control model.
 * - Users can only read/write their own profile data.
 * - Destinations are publicly readable. Only users with the 'pengelola' role or 'admin' can manage destinations, and only if they're assigned to the destination.
 * - Categories are not writable from client, so write operation are completely disabled.
 * - Countries are not writable from client, so write operation are completely disabled.
 * - Visit data for destinations is managed by 'pengelola' and 'admin' users assigned to those destinations.
 * - Unlock requests can be created by any signed-in user, but only 'pengelola' and 'admin' users can process/modify them.
 * - App settings are only writable by 'admin' users.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles.
 * - /destinations/{destinationId}: Stores destination information.
 * - /destinations/{destinationId}/visits/{visitId}: Stores visit data for destinations.
 * - /categories/{categoryId}: Stores destination categories.
 * - /countries/{countryId}: Stores countries data.
 * - /unlock-requests/{requestId}: Stores unlock requests.
 * - /settings/app: Stores global app settings.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Roles are used to determine elevated privileges (e.g., managing destinations, updating app settings).
 * - Users assignedLocations are used to control access to destinations and their visit data.
 *
 * Denormalization for Authorization:
 * The assignedLocations field in the UserProfile is used for authorization when modifying destinations and visit data.
 * The request data must have a destinationId for validating the user's assigned locations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages access to user profiles.
     * @path /users/{userId}
     * @allow (create) - User can create their own profile if the UID matches.
     * @allow (get, list, update, delete) - User can only access their own profile.
     * @deny (create) - User cannot create a profile with a mismatched UID.
     * @deny (update, delete) - User cannot modify or delete another user's profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // User listing is not allowed.
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages access to destination data.
     * @path /destinations/{destinationId}
     * @allow (get, list) - Anyone can read destination data.
     * @allow (create) - Only users with 'pengelola' or 'admin' roles and the destination in their assignedLocations can create destinations.
     * @allow (update, delete) - Only users with 'pengelola' or 'admin' roles and the destination in their assignedLocations can update or delete destinations.
     * @deny (create, update, delete) - Users without the required role or destination assignment cannot modify destination data.
     * @principle Restricts writes based on role and assigned locations.
     */
    match /destinations/{destinationId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isPengelolaOrAdmin() {
            return isSignedIn() && (getUserRole() == 'pengelola' || getUserRole() == 'admin');
        }

        function getUserRole() {
            return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
        }

        function isAssignedDestination(destinationId) {
            return isSignedIn() && destinationId in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.assignedLocations;
        }

        function canManageDestination(destinationId) {
            return isPengelolaOrAdmin() && isAssignedDestination(destinationId);
        }

        function existingCanManageDestination(destinationId) {
          return canManageDestination(destinationId) && resource.data != null;
        }

        allow get, list: if true;
        allow create: if isSignedIn() && canManageDestination(destinationId);
        allow update: if isSignedIn() && existingCanManageDestination(destinationId);
        allow delete: if isSignedIn() && existingCanManageDestination(destinationId);
    }

    /**
     * @description Access rules for destination categories.
     * @path /categories/{categoryId}
     * @allow (get, list) - Allows public read access to categories.
     * @deny (create, update, delete) - Denies all client-side write access to categories, as these should be managed via a separate admin interface.
     * @principle Enforces read-only access for categories.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create: if false; // Adding category is not allowed.
      allow update: if false; // Updating category is not allowed.
      allow delete: if false; // Deleting category is not allowed.
    }

    /**
     * @description Access rules for countries.
     * @path /countries/{countryId}
     * @allow (get, list) - Allows public read access to countries.
     * @deny (create, update, delete) - Denies all client-side write access to countries, as these should be managed via a separate admin interface.
     * @principle Enforces read-only access for countries.
     */
    match /countries/{countryId} {
        allow get, list: if true;
        allow create: if false; // Adding country is not allowed.
        allow update: if false; // Updating country is not allowed.
        allow delete: if false; // Deleting country is not allowed.
    }

    /**
     * @description Manages access to visit data for destinations.
     * @path /destinations/{destinationId}/visits/{visitId}
     * @allow (get, list) - Anyone can read visit data.
     * @allow (create) - Only users with 'pengelola' or 'admin' roles and the destination in their assignedLocations can create visit data.
     * @allow (update, delete) - Only users with 'pengelola' or 'admin' roles and the destination in their assignedLocations can update or delete visit data.
     * @deny (create, update, delete) - Users without the required role or destination assignment cannot modify visit data.
     * @principle Restricts writes based on role and assigned locations, inheriting destination-level permissions.
     */
    match /destinations/{destinationId}/visits/{visitId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isPengelolaOrAdmin() {
            return isSignedIn() && (getUserRole() == 'pengelola' || getUserRole() == 'admin');
        }

        function getUserRole() {
            return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
        }

        function isAssignedDestination(destinationId) {
            return isSignedIn() && destinationId in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.assignedLocations;
        }

        function canManageVisitData(destinationId) {
            return isPengelolaOrAdmin() && isAssignedDestination(destinationId);
        }

        function existingCanManageVisitData(destinationId) {
          return canManageVisitData(destinationId) && resource.data != null;
        }

        allow get, list: if true;
        allow create: if isSignedIn() && canManageVisitData(destinationId);
        allow update: if isSignedIn() && existingCanManageVisitData(destinationId);
        allow delete: if isSignedIn() && existingCanManageVisitData(destinationId);
    }

    /**
     * @description Manages access to unlock requests.
     * @path /unlock-requests/{requestId}
     * @allow (create) - Any signed-in user can create an unlock request.
     * @allow (get, list) - Any signed-in user can read unlock requests.
     * @allow (update) - Only users with 'pengelola' or 'admin' roles can update unlock requests.
     * @deny (delete) - No user can delete unlock requests.
     * @principle Allows creation by all users, but restricts processing to specific roles.
     */
    match /unlock-requests/{requestId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isPengelolaOrAdmin() {
            return isSignedIn() && (getUserRole() == 'pengelola' || getUserRole() == 'admin');
        }

        function getUserRole() {
            return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
        }

        function existingIsPengelolaOrAdmin() {
          return isPengelolaOrAdmin() && resource.data != null;
        }

        allow get, list: if isSignedIn();
        allow create: if isSignedIn();
        allow update: if isSignedIn() && existingIsPengelolaOrAdmin();
        allow delete: if false;
    }

    /**
     * @description Manages access to global application settings.
     * @path /settings/app
     * @allow (get) - Anyone can read app settings.
     * @allow (update) - Only users with the 'admin' role can update app settings.
     * @deny (create, delete) - App settings should not be created or deleted through the client.
     * @principle Restricts writes to admin users.
     */
    match /settings/app {
        function isSignedIn() {
            return request.auth != null;
        }

        function isAdmin() {
            return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
        }

        function existingIsAdmin() {
          return isAdmin() && resource.data != null;
        }

        allow get: if true;
        allow create: if false;
        allow update: if isSignedIn() && existingIsAdmin();
        allow delete: if false;
    }
  }
}