/**
 * @fileOverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a role-based access control model.
 *   - Users can only read and write their own profiles.
 *   - Destinations and Categories are publicly readable but only writeable by users with specific roles (admin, pengelola).
 *   - Monthly visit data for destinations is secured for owner-only access and requires the user to have a specific role or access.
 *   - Unlock requests can be created by any signed-in user, and managed by users with specific roles.
 *
 * Data Structure:
 * - /users/{userId}: Stores public user profile information.
 * - /destinations/{destinationId}: Stores tourist destination information.
 * - /categories/{categoryId}: Stores destination categories.
 * - /countries/{countryId}: Stores countries data.
 * - /destinations/{destinationId}/visits/{visitId}: Stores visit data for destinations.
 * - /unlock-requests/{requestId}: Stores unlock requests.
 * - /settings/app: Stores global application settings (singleton document).
 *
 * Key Security Decisions:
 * - User listing is disallowed to protect privacy.
 * - Strict ownership is enforced for user profiles.
 * - Global settings are publicly readable, but only writeable by admins.
 * - Missing ownership field for Recipes requires a future schema update for secure writes.
 *
 * Denormalization for Authorization:
 *  - User profiles are stored under /users/{userId}, allowing easy ownership checks via the `isOwner()` function.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Users can read and write their own profile data. Listing all users is disallowed.
     * @path /users/{userId}
     * @allow (create, update, get, delete) if the user's UID matches the userId.
     * @deny (create, update, get, delete) if the user's UID does not match the userId.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Secure tourist destination information. Publicly readable, but only writeable by authorized users.
     * @path /destinations/{destinationId}
     * @allow (get, list) any user can read destination information.
     * @allow (create, update, delete) only 'admin' or 'pengelola' can modify destination information.
     * @deny (create, update, delete) if the user is not an 'admin' or 'pengelola'.
     * @principle Restricts write access to authorized roles.
     */
    match /destinations/{destinationId} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn() && (getUserRole() == 'admin' || getUserRole() == 'pengelola');
    }

    /**
     * @description Secure destination categories. Publicly readable, but only writeable by authorized users.
     * @path /categories/{categoryId}
     * @allow (get, list) any user can read category information.
     * @allow (create, update, delete) only 'admin' or 'pengelola' can modify category information.
     * @deny (create, update, delete) if the user is not an 'admin' or 'pengelola'.
     * @principle Restricts write access to authorized roles.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn() && (getUserRole() == 'admin' || getUserRole() == 'pengelola');
    }

    /**
     * @description Secure countries data. Publicly readable, but only writeable by authorized users.
     * @path /countries/{countryId}
     * @allow (get, list) any user can read country information.
     * @allow (create, update, delete) only 'admin' or 'pengelola' can modify country information.
     * @deny (create, update, delete) if the user is not an 'admin' or 'pengelola'.
     * @principle Restricts write access to authorized roles.
     */
    match /countries/{countryId} {
        allow get, list: if true;
        allow create, update, delete: if isSignedIn() && (getUserRole() == 'admin' || getUserRole() == 'pengelola');
    }

    /**
     * @description Secure monthly visit data for a specific destination.
     * @path /destinations/{destinationId}/visits/{visitId}
     * @allow (get, list) any user can read visit data.
     * @allow (create, update, delete) only users with 'admin' or 'pengelola' role can modify visit data.
     * @deny (create, update, delete) if the user is not an 'admin' or 'pengelola'.
     * @principle Restricts write access to authorized roles.
     */
    match /destinations/{destinationId}/visits/{visitId} {
        allow get, list: if true;
        allow create, update, delete: if isSignedIn() && (getUserRole() == 'admin' || getUserRole() == 'pengelola');
    }

    /**
     * @description Secure unlock requests. Any signed-in user can create a request. Only admins and pengelola can update/delete requests.
     * @path /unlock-requests/{requestId}
     * @allow (create) any signed-in user can create a request.
     * @allow (get, list) any user can read unlock requests.
     * @allow (update, delete) only users with 'admin' or 'pengelola' role can modify unlock requests.
     * @deny (update, delete) if the user is not an 'admin' or 'pengelola'.
     * @principle Allows self-creation of unlock requests, restricts management to authorized roles.
     */
    match /unlock-requests/{requestId} {
        allow get, list: if true;
        allow create: if isSignedIn();
        allow update, delete: if isSignedIn() && (getUserRole() == 'admin' || getUserRole() == 'pengelola') && resource != null;
    }

    /**
     * @description Secure global application settings. Publicly readable, but only writeable by admins.
     * @path /settings/app
     * @allow (get) any user can read the application settings.
     * @allow (update) only 'admin' role can modify application settings.
     * @deny (update) if the user is not an 'admin'.
     * @principle Restricts write access to authorized roles. Singleton document.
     */
    match /settings/app {
        allow get: if true;
        allow create, update, delete: if isSignedIn() && getUserRole() == 'admin' && resource != null;
    }

    // --- Helper functions ---

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the resource.
     * @param {string} userId The user ID to compare against the request's auth UID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Gets the role of the current user.
     * @return {string} The user's role or null if not found.
     */
    function getUserRole() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }
  }
}