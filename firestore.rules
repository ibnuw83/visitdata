/**
 * @fileoverview Firestore Security Rules for Prototyping.
 *
 * Core Philosophy:
 * This ruleset implements a role-based access control model with "admin" and "pengelola" (manager) roles.
 * It prioritizes secure authorization by enforcing role-based access and ownership constraints. Data shape
 * validation is relaxed to facilitate rapid prototyping and schema iteration.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information; accessible to the user and admins.
 * - /destinations/{destinationId}: Publicly readable; only admins can modify.
 * - /destinations/{destinationId}/visits/{visitId}: Accessible to admins and assigned "pengelola" for the specific destination.
 * - /categories/{categoryId}: Publicly readable; immutable (admins cannot modify either).
 * - /countries/{countryId}: Publicly readable; immutable (admins cannot modify either).
 * - /unlock-requests/{requestId}: Accessible only to admins.
 * - /settings/{docId}: Accessible only to admins.
 *
 * Key Security Decisions:
 * - User listing is restricted to admins only.
 * - "categories" and "countries" collections are read-only (no create, update, or delete allowed, even for admins).
 * - Strict enforcement of ownership and role-based access is implemented using helper functions (e.g., `isOwner()`, `isAdmin()`, `isPengelola()`).
 * - For prototyping, detailed schema validation is omitted.
 *
 * Denormalization for Authorization:
 * - The `isPengelola()` function retrieves the user's profile to check their role and assigned locations, which is expensive. However, without a members array in the
 *   destinations data we must retrieve the user's assigned locations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /** ------------------------------
     *  üîê GLOBAL HELPER FUNCTIONS
     *  ------------------------------ */
    function isSignedIn() {
      return request.auth != null;
    }

    function getUserProfile() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function isAdmin() {
      return isSignedIn() && getUserProfile().role == 'admin';
    }

    function isPengelola(destinationId) {
      let userProfile = getUserProfile();
      return isSignedIn() &&
             userProfile.role == 'pengelola' &&
             userProfile.assignedLocations.hasAny([destinationId]);
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /** ------------------------------
     *  üë§ USERS COLLECTION
     *  ------------------------------
     *  @description Controls access to user profile documents.
     *  @path /users/{userId}
     *  @allow (get) Authenticated user can read their own profile or an admin can read any profile.
     *  @allow (create) Authenticated user can create their own profile if the UID matches.
     *  @allow (update) Authenticated user can update their own profile or an admin can update any profile, ensuring the UID remains consistent.
     *  @allow (delete) Only admins can delete user profiles.
     *  @deny (get) Authenticated user tries to read another user's profile without admin privileges.
     *  @deny (create) Unauthenticated user attempts to create a profile.
     *  @deny (update) Authenticated user attempts to modify the UID in their profile.
     *  @deny (delete) Non-admin user attempts to delete a profile.
     *  @principle Enforces user-ownership for profile access and admin control.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && (isOwner(userId) || isAdmin());
      allow list: if isAdmin();
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isExistingOwner(userId) && (isAdmin() || isOwner(userId)) && request.resource.data.uid == resource.data.uid;
      allow delete: if isAdmin();
    }

    /** ------------------------------
     *  üèù DESTINATIONS COLLECTION
     *  @description Controls access to destination documents.
     *  @path /destinations/{destinationId}
     *  @allow (get, list) Public read access to destination information.
     *  @allow (create, update, delete) Only admins can modify destination documents.
     *  @deny (create, update, delete) Non-admin user attempts to modify a destination.
     *  @principle Allows public read access while restricting modifications to admins.
     */
    match /destinations/{destinationId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;

      /** --------------------------
       *  üìä SUBCOLLECTION: VISITS
       *  @description Controls access to visit data subcollection for destinations.
       *  @path /destinations/{destinationId}/visits/{visitId}
       *  @allow (get, list, create, update, delete) Admins or "pengelola" assigned to the destination can manage visit data.
       *  @deny (get, list, create, update, delete) Non-admin or non-"pengelola" attempts to access visit data.
       *  @principle Restricts access to visit data to authorized personnel (admins and assigned "pengelola").
       */
      match /visits/{visitId} {
        allow get: if isSignedIn() && (isAdmin() || isPengelola(destinationId));
        allow list: if isSignedIn() && (isAdmin() || isPengelola(destinationId));
        allow create: if isSignedIn() && (isAdmin() || isPengelola(destinationId));
        allow update: if isSignedIn() && (isAdmin() || isPengelola(destinationId)) && resource != null;
        allow delete: if isSignedIn() && (isAdmin() || isPengelola(destinationId)) && resource != null;
      }
    }

    /** ------------------------------
     *  üóÇ CATEGORIES COLLECTION
     *  @description Controls access to destination categories.
     *  @path /categories/{categoryId}
     *  @allow (get, list) Public read access to categories.
     *  @deny (create, update, delete) No one can create, update, or delete categories (immutable).
     *  @principle Ensures categories are read-only and immutable.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /** ------------------------------
     *  üåç COUNTRIES COLLECTION
     *  @description Controls access to countries data.
     *  @path /countries/{countryId}
     *  @allow (get, list) Public read access to countries.
     *  @deny (create, update, delete) No one can create, update, or delete countries (immutable).
     *  @principle Ensures countries are read-only and immutable.
     */
    match /countries/{countryId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /** ------------------------------
     *  üîì UNLOCK REQUESTS
     *  @description Controls access to unlock requests.
     *  @path /unlock-requests/{requestId}
     *  @allow (get, list, create, update, delete) Only admins can manage unlock requests.
     *  @deny (get, list, create, update, delete) Non-admin user attempts to manage unlock requests.
     *  @principle Restricts unlock request management to administrators.
     */
    match /unlock-requests/{requestId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /** ------------------------------
     *  ‚öôÔ∏è APP SETTINGS
     *  @description Controls access to application settings.
     *  @path /settings/{docId}
     *  @allow (get, list, create, update, delete) Only admins can manage application settings.
     *  @deny (get, list, create, update, delete) Non-admin user attempts to manage application settings.
     *  @principle Restricts application setting management to administrators.
     */
    match /settings/{docId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }
  }
}